<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>
Some simple C++ programs
</title>
<link rel="stylesheet" type="text/css" href="style.css">
<link href="shCore.css" rel="stylesheet" type="text/css" />
<link href="shThemeDefault.css" rel="stylesheet" type="text/css" />
</head>

<body>
<div class="bodysection">

<div class="topsection">
	<h1>
		Thoughts on C++ programming language
	</h1>
</div>

<div class="mainsection">
	<p>
		<a href="index.html">Back to Home</a>
	</p>
	<h1>
		Introduction:
	</h1>
	<p>
		C++ is a beautiful and powerful language. Here is some thoughts (I think) make it just a little better.
	</p>	
	<h2>
		Constant Memory Queue operator
	</h2>
	<p>
		I am thinking of an operator which can access a variable bitwise:
	</p>
<pre class='brush: cpp'>
	int a;
	unsigned int b;
	a=-1;
	b=$a;									// copy a to b bit by bit
	
	double x;=1.23							// copy a double variable bits to an int variable to
	unsigned long long i=$x;				// easily perform bit operation by copy to an int variable 
</pre>
	<p>
		It may be accessed as a constant:
	</p>
<pre class='brush: cpp'>
	int a;
	int b;
	a=1;
	b=++$a;									// b is set to 2, but a remains 1
</pre>
	<p>
		It has a binary nature:
	</p>
<pre class='brush: cpp'>
	int a=1;
	cout << $a;								// will be displayed as characters
</pre>
	<p>
		This operator can make a memory queue:
	</p>
<pre class='brush: cpp'>
	long hi=5;
	long lo=4;
	long long i=$(hi, lo)
	
	std::map< long long,int > m;
	m[$(2,3)]=10;							// example: access std::map as a 2-dimensional array
</pre>
	<p>
		It may be used for functions which returning multiple values:
	</p>
<pre class='brush: cpp'>
$(int, int) minmax(int a, int b)
{
	if (a < b)
		return $(a, b);
	else
		return $(b, a);	
}
</pre>
	<h2>
		Loops
	</h2>
	<p>
		It is great if Sets can be defined like something below:
	</p>
<pre class='brush: cpp'>
	for (i:[a:b])							// same as for (i = a; i <= b; i++)
		doSomething;
	// it can be extended to below definitions:
	// [a:b]			a > b		(i = a; i >= b; i--)
	// [a:step:b]					(i = a; i <= b; i+=step)
	// [a:b[						(i = a; i < b; i++)
	// ]a:b]						(i = a+1; i <= b; i++)
	// ]a:b[						(i = a+1; i < b; i++)
</pre>
	<p>
		This notation can be used with iterators:
	</p>
<pre class='brush: cpp'>
	for (auto it : var[])							// iterating through every element
		doSomething;
	// (auto it : var]])							// iterating through elements not including first element
	// (auto it : var[[)							// iterating through elements not including last element
	// (auto it : var][)							// iterating through elements not including first and last elements
</pre>
	<p>
		Access two iterators at once using Queue operator:
	</p>
<pre class='brush: cpp'>
	for (auto $(it_first,it_second) : var[])		// access two following iterators
		doSomething;								// in the loop, it_first can be erased or modified
													// it_second can be erased if then set to it_first
</pre>
	<p>
		"where" keyword may be defined as below:
	</p>
<pre class='brush: cpp'>
	for (i:[a,b]) where (m[i] > 5)
		doSomething;
	// is equivalent to
	for (i = a; i <= b; i++)
		if (m[i] > 5)
			doSomething;
</pre>
	<p>
		"skip" keyword may be defined as below:
	</p>
<pre class='brush: cpp'>
	for (i:[a,b]) skip (m[i] == 5)
		doSomething;
	// is equivalent to
	for (i = a; i <= b; i++)
		if (m[i] != 5)
			doSomething;
</pre>
	<p>
		"until" keyword may be defined as below:
	</p>
<pre class='brush: cpp'>
	until (m==target)
	{
		doSomething;
	}
	do {
		doSomething;
	} until (m==target);
	
	// is equivalent to
	while (m!=target)
	{
		doSomething;
	}
	do {
		doSomething;
	} while (m!=target);	
</pre>
	<p>
		"break" definition can be extended: (the same for "continue")
	</p>
<pre class='brush: cpp'>
	for (i:[a,b])
		for (j:[c,d])
			for (k:[e,f])
			{
				if (expr1)
					break j;						// execute the next statement outside for (j:[c,d]) loop
				if (expr2)
					continue j;						// transfer of control to for (j:[c,d])
			}
</pre>
	<p>
		"onbreak" can be defined as below:
	</p>
<pre class='brush: cpp'>
	for (i:[a,b])
	{
		doSomething;
		if (expr)
			break;
	} onbreak {
		...
	}	
</pre>
	<h2>
		Formatted input
	</h2>
	<p>
		Suppose a comma separated values file is read. How about using constants in Input statements:
	</p>
<pre class='brush: cpp'>
	cin >> a >> "," >> b >> "," >> c;

	ifstream myfile ("example.txt");
	if (myfile.is_open())
		myfile >> a >> "," >> b >> "," >> c;
	// control format and error can be handled
</pre>
</div>

</div>
<script src="shCore.js"></script>
<script src="shBrushCpp.js"></script>
<script>
	SyntaxHighlighter.all()
</script>
</body>
</html>